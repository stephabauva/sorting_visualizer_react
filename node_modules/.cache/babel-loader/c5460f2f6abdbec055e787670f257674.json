{"ast":null,"code":"/*merge sort*/\nexport function doMergeSort(array) {\n  const animations = [];\n  if (array.length <= 1) return array;\n  divide(array, animations);\n  return animations;\n}\n\nfunction divide(array, animations) {\n  var midPoint = Math.ceil(array.length / 2); //rounds to next integer\n\n  var leftArray = array.slice(0, midPoint); //from start to middle item (mid item not included)\n\n  var rightArray = array.slice(midPoint); //starts at mid item (includes mid item)\n\n  if (midPoint > 1) {\n    leftArray = divide(leftArray, animations);\n    rightArray = divide(rightArray, animations);\n  }\n\n  return merge(leftArray, rightArray, animations);\n}\n\nfunction merge(leftArray, rightArray, animations) {\n  var leftIndex = 0; // to keep track if we visited all item of the array\n\n  var rightIndex = 0; // same here\n\n  var merged = [];\n\n  while (leftIndex < leftArray.length || rightIndex < rightArray.length) {\n    // ||=OR\n    animations.push([leftIndex, rightIndex]);\n    animations.push([leftIndex, rightIndex]);\n    var leftArrayItem = leftArray[leftIndex];\n    var rightArrayItem = rightArray[rightIndex];\n\n    if (leftArrayItem !== undefined) {\n      //if there is an item an the left\n      if (rightArrayItem === undefined) {\n        //but nothing on the right\n        merged.push(leftArrayItem); //then just push the left item to the ordered list\n\n        leftIndex++;\n      } else {\n        if (leftArrayItem <= rightArrayItem) {\n          //if left exists and is <= to right, just push the left\n          merged.push(leftArrayItem);\n          leftIndex++;\n        } else {\n          merged.push(rightArrayItem); //otherwise, left is > to right so just push the right item\n\n          rightIndex++;\n        }\n      }\n    } else {\n      if (rightArrayItem !== undefined) {\n        merged.push(rightArrayItem);\n        rightIndex++;\n      }\n    }\n  }\n\n  return merged;\n}\n\ndoMergeSort([4, 1, 6, 3, 2, 1]);","map":{"version":3,"sources":["/Users/urdoom/sorting_visualizer_react/src/sortingAlgorithms/SortingAlgorithms.js"],"names":["doMergeSort","array","animations","length","divide","midPoint","Math","ceil","leftArray","slice","rightArray","merge","leftIndex","rightIndex","merged","push","leftArrayItem","rightArrayItem","undefined"],"mappings":"AACA;AACA,OAAO,SAASA,WAAT,CAAqBC,KAArB,EAA4B;AAC/B,QAAMC,UAAU,GAAG,EAAnB;AACA,MAAID,KAAK,CAACE,MAAN,IAAgB,CAApB,EAAuB,OAAOF,KAAP;AACvBG,EAAAA,MAAM,CAACH,KAAD,EAAQC,UAAR,CAAN;AACA,SAAOA,UAAP;AACH;;AAED,SAASE,MAAT,CAAgBH,KAAhB,EAAuBC,UAAvB,EAAmC;AAC/B,MAAIG,QAAQ,GAAGC,IAAI,CAACC,IAAL,CAAUN,KAAK,CAACE,MAAN,GAAe,CAAzB,CAAf,CAD+B,CACa;;AAC5C,MAAIK,SAAS,GAAGP,KAAK,CAACQ,KAAN,CAAY,CAAZ,EAAeJ,QAAf,CAAhB,CAF+B,CAEW;;AAC1C,MAAIK,UAAU,GAAGT,KAAK,CAACQ,KAAN,CAAYJ,QAAZ,CAAjB,CAH+B,CAGS;;AACxC,MAAIA,QAAQ,GAAG,CAAf,EAAkB;AACdG,IAAAA,SAAS,GAAGJ,MAAM,CAACI,SAAD,EAAYN,UAAZ,CAAlB;AACAQ,IAAAA,UAAU,GAAGN,MAAM,CAACM,UAAD,EAAaR,UAAb,CAAnB;AACH;;AACD,SAAOS,KAAK,CAACH,SAAD,EAAYE,UAAZ,EAAwBR,UAAxB,CAAZ;AACH;;AACD,SAASS,KAAT,CAAeH,SAAf,EAA0BE,UAA1B,EAAsCR,UAAtC,EAAkD;AAC9C,MAAIU,SAAS,GAAG,CAAhB,CAD8C,CAC3B;;AACnB,MAAIC,UAAU,GAAG,CAAjB,CAF8C,CAE1B;;AACpB,MAAIC,MAAM,GAAG,EAAb;;AACA,SAAOF,SAAS,GAAGJ,SAAS,CAACL,MAAtB,IAAgCU,UAAU,GAAGH,UAAU,CAACP,MAA/D,EAAuE;AAAE;AACrED,IAAAA,UAAU,CAACa,IAAX,CAAgB,CAACH,SAAD,EAAYC,UAAZ,CAAhB;AACAX,IAAAA,UAAU,CAACa,IAAX,CAAgB,CAACH,SAAD,EAAYC,UAAZ,CAAhB;AACA,QAAIG,aAAa,GAAGR,SAAS,CAACI,SAAD,CAA7B;AACA,QAAIK,cAAc,GAAGP,UAAU,CAACG,UAAD,CAA/B;;AACA,QAAIG,aAAa,KAAKE,SAAtB,EAAiC;AAAE;AAC/B,UAAID,cAAc,KAAKC,SAAvB,EAAkC;AAAE;AAChCJ,QAAAA,MAAM,CAACC,IAAP,CAAYC,aAAZ,EAD8B,CACF;;AAC5BJ,QAAAA,SAAS;AACZ,OAHD,MAIK;AACD,YAAII,aAAa,IAAIC,cAArB,EAAqC;AAAE;AACnCH,UAAAA,MAAM,CAACC,IAAP,CAAYC,aAAZ;AACAJ,UAAAA,SAAS;AACZ,SAHD,MAIK;AACDE,UAAAA,MAAM,CAACC,IAAP,CAAYE,cAAZ,EADC,CAC4B;;AAC7BJ,UAAAA,UAAU;AACb;AACJ;AACJ,KAfD,MAgBK;AACD,UAAII,cAAc,KAAKC,SAAvB,EAAkC;AAC9BJ,QAAAA,MAAM,CAACC,IAAP,CAAYE,cAAZ;AACAJ,QAAAA,UAAU;AACb;AACJ;AACJ;;AACD,SAAOC,MAAP;AACH;;AAEDd,WAAW,CAAC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,EAAS,CAAT,EAAW,CAAX,CAAD,CAAX","sourcesContent":["\n/*merge sort*/\nexport function doMergeSort(array) {\n    const animations = [];\n    if (array.length <= 1) return array;\n    divide(array, animations);\n    return animations;\n}\n\nfunction divide(array, animations) {\n    var midPoint = Math.ceil(array.length / 2); //rounds to next integer\n    var leftArray = array.slice(0, midPoint); //from start to middle item (mid item not included)\n    var rightArray = array.slice(midPoint); //starts at mid item (includes mid item)\n    if (midPoint > 1) {\n        leftArray = divide(leftArray, animations);\n        rightArray = divide(rightArray, animations);\n    }\n    return merge(leftArray, rightArray, animations);\n}\nfunction merge(leftArray, rightArray, animations) {\n    var leftIndex = 0; // to keep track if we visited all item of the array\n    var rightIndex = 0; // same here\n    var merged = [];\n    while (leftIndex < leftArray.length || rightIndex < rightArray.length) { // ||=OR\n        animations.push([leftIndex, rightIndex]);\n        animations.push([leftIndex, rightIndex]);\n        var leftArrayItem = leftArray[leftIndex];\n        var rightArrayItem = rightArray[rightIndex];\n        if (leftArrayItem !== undefined) { //if there is an item an the left\n            if (rightArrayItem === undefined) { //but nothing on the right\n                merged.push(leftArrayItem); //then just push the left item to the ordered list\n                leftIndex++;\n            }\n            else {\n                if (leftArrayItem <= rightArrayItem) { //if left exists and is <= to right, just push the left\n                    merged.push(leftArrayItem);\n                    leftIndex++;\n                }\n                else {\n                    merged.push(rightArrayItem); //otherwise, left is > to right so just push the right item\n                    rightIndex++;\n                }\n            }\n        }\n        else {\n            if (rightArrayItem !== undefined) {\n                merged.push(rightArrayItem);\n                rightIndex++;\n            }\n        }\n    }\n    return merged;\n}\n\ndoMergeSort([4,1,6,3,2,1])"]},"metadata":{},"sourceType":"module"}