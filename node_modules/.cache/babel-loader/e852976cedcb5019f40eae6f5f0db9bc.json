{"ast":null,"code":"/*merge sort*/\nexport function doMergeSort(array) {\n  const animations = [];\n  if (array.length <= 1) return array;\n  const auxiliaryArray = array.slice();\n  const merged = divide(array, animations, auxiliaryArray);\n  return merged;\n}\n\nfunction divide(array, animations, auxiliaryArray) {\n  const midPoint = Math.ceil(array.length / 2); //rounds to next integer\n\n  const leftArray = array.slice(0, midPoint); //from start to middle item (mid item not included)\n\n  const rightArray = array.slice(midPoint); //starts at mid item (includes mid item)\n\n  if (midPoint > 1) {\n    divide(leftArray, animations, auxiliaryArray);\n    divide(rightArray, animations, auxiliaryArray);\n  }\n\n  return merge(leftArray, rightArray, animations, auxiliaryArray);\n}\n\nfunction merge(leftArray, rightArray, animations, auxiliaryArray) {\n  let leftIndex = 0; // to keep track if we visited all item of the array\n\n  let rightIndex = 0; // same here\n\n  const merged = [];\n\n  while (leftIndex < leftArray.length || rightIndex < rightArray.length) {\n    // ||=OR\n    animations.push([leftIndex, rightIndex]);\n    animations.push([leftIndex, rightIndex]);\n    const leftArrayItem = leftArray[leftIndex];\n    const rightArrayItem = rightArray[rightIndex];\n\n    if (leftArrayItem !== undefined) {\n      //if there is an item an the left\n      if (rightArrayItem === undefined) {\n        //but nothing on the right\n        merged.push(leftArrayItem); //then just push the left item to the ordered list\n\n        leftIndex++;\n      } else {\n        if (leftArrayItem <= rightArrayItem) {\n          //if left exists and is <= to right, just push the left\n          merged.push(leftArrayItem);\n          leftIndex++;\n        } else {\n          merged.push(rightArrayItem); //otherwise, left is > to right so just push the right item\n\n          rightIndex++;\n        }\n      }\n    } else {\n      if (rightArrayItem !== undefined) {\n        merged.push(rightArrayItem);\n        rightIndex++;\n      }\n    }\n  }\n\n  return merged;\n}","map":{"version":3,"sources":["/Users/urdoom/sorting_visualizer_react/src/sortingAlgorithms/SortingAlgorithms.js"],"names":["doMergeSort","array","animations","length","auxiliaryArray","slice","merged","divide","midPoint","Math","ceil","leftArray","rightArray","merge","leftIndex","rightIndex","push","leftArrayItem","rightArrayItem","undefined"],"mappings":"AACA;AACA,OAAO,SAASA,WAAT,CAAqBC,KAArB,EAA4B;AAC/B,QAAMC,UAAU,GAAG,EAAnB;AACA,MAAID,KAAK,CAACE,MAAN,IAAgB,CAApB,EAAuB,OAAOF,KAAP;AACvB,QAAMG,cAAc,GAAGH,KAAK,CAACI,KAAN,EAAvB;AACA,QAAMC,MAAM,GAAGC,MAAM,CAACN,KAAD,EAAQC,UAAR,EAAoBE,cAApB,CAArB;AACA,SAAOE,MAAP;AACH;;AAED,SAASC,MAAT,CAAgBN,KAAhB,EAAuBC,UAAvB,EAAmCE,cAAnC,EAAmD;AAC/C,QAAMI,QAAQ,GAAGC,IAAI,CAACC,IAAL,CAAUT,KAAK,CAACE,MAAN,GAAe,CAAzB,CAAjB,CAD+C,CACD;;AAC9C,QAAMQ,SAAS,GAAGV,KAAK,CAACI,KAAN,CAAY,CAAZ,EAAeG,QAAf,CAAlB,CAF+C,CAEH;;AAC5C,QAAMI,UAAU,GAAGX,KAAK,CAACI,KAAN,CAAYG,QAAZ,CAAnB,CAH+C,CAGL;;AAC1C,MAAIA,QAAQ,GAAG,CAAf,EAAkB;AACdD,IAAAA,MAAM,CAACI,SAAD,EAAYT,UAAZ,EAAwBE,cAAxB,CAAN;AACAG,IAAAA,MAAM,CAACK,UAAD,EAAaV,UAAb,EAAyBE,cAAzB,CAAN;AACH;;AACD,SAAOS,KAAK,CAACF,SAAD,EAAYC,UAAZ,EAAwBV,UAAxB,EAAoCE,cAApC,CAAZ;AACH;;AACD,SAASS,KAAT,CAAeF,SAAf,EAA0BC,UAA1B,EAAsCV,UAAtC,EAAkDE,cAAlD,EAAkE;AAC9D,MAAIU,SAAS,GAAG,CAAhB,CAD8D,CAC3C;;AACnB,MAAIC,UAAU,GAAG,CAAjB,CAF8D,CAE1C;;AACpB,QAAMT,MAAM,GAAG,EAAf;;AACA,SAAOQ,SAAS,GAAGH,SAAS,CAACR,MAAtB,IAAgCY,UAAU,GAAGH,UAAU,CAACT,MAA/D,EAAuE;AAAE;AACrED,IAAAA,UAAU,CAACc,IAAX,CAAgB,CAACF,SAAD,EAAYC,UAAZ,CAAhB;AACAb,IAAAA,UAAU,CAACc,IAAX,CAAgB,CAACF,SAAD,EAAYC,UAAZ,CAAhB;AACA,UAAME,aAAa,GAAGN,SAAS,CAACG,SAAD,CAA/B;AACA,UAAMI,cAAc,GAAGN,UAAU,CAACG,UAAD,CAAjC;;AACA,QAAIE,aAAa,KAAKE,SAAtB,EAAiC;AAAE;AAC/B,UAAID,cAAc,KAAKC,SAAvB,EAAkC;AAAE;AAChCb,QAAAA,MAAM,CAACU,IAAP,CAAYC,aAAZ,EAD8B,CACF;;AAC5BH,QAAAA,SAAS;AACZ,OAHD,MAIK;AACD,YAAIG,aAAa,IAAIC,cAArB,EAAqC;AAAE;AACnCZ,UAAAA,MAAM,CAACU,IAAP,CAAYC,aAAZ;AACAH,UAAAA,SAAS;AACZ,SAHD,MAIK;AACDR,UAAAA,MAAM,CAACU,IAAP,CAAYE,cAAZ,EADC,CAC4B;;AAC7BH,UAAAA,UAAU;AACb;AACJ;AACJ,KAfD,MAgBK;AACD,UAAIG,cAAc,KAAKC,SAAvB,EAAkC;AAC9Bb,QAAAA,MAAM,CAACU,IAAP,CAAYE,cAAZ;AACAH,QAAAA,UAAU;AACb;AACJ;AACJ;;AACD,SAAOT,MAAP;AACH","sourcesContent":["\n/*merge sort*/\nexport function doMergeSort(array) {\n    const animations = [];\n    if (array.length <= 1) return array;\n    const auxiliaryArray = array.slice();\n    const merged = divide(array, animations, auxiliaryArray);\n    return merged;\n}\n\nfunction divide(array, animations, auxiliaryArray) {\n    const midPoint = Math.ceil(array.length / 2); //rounds to next integer\n    const leftArray = array.slice(0, midPoint); //from start to middle item (mid item not included)\n    const rightArray = array.slice(midPoint); //starts at mid item (includes mid item)\n    if (midPoint > 1) {\n        divide(leftArray, animations, auxiliaryArray);\n        divide(rightArray, animations, auxiliaryArray);\n    }\n    return merge(leftArray, rightArray, animations, auxiliaryArray);\n}\nfunction merge(leftArray, rightArray, animations, auxiliaryArray) {\n    let leftIndex = 0; // to keep track if we visited all item of the array\n    let rightIndex = 0; // same here\n    const merged = [];\n    while (leftIndex < leftArray.length || rightIndex < rightArray.length) { // ||=OR\n        animations.push([leftIndex, rightIndex]);\n        animations.push([leftIndex, rightIndex]);\n        const leftArrayItem = leftArray[leftIndex];\n        const rightArrayItem = rightArray[rightIndex];\n        if (leftArrayItem !== undefined) { //if there is an item an the left\n            if (rightArrayItem === undefined) { //but nothing on the right\n                merged.push(leftArrayItem); //then just push the left item to the ordered list\n                leftIndex++;\n            }\n            else {\n                if (leftArrayItem <= rightArrayItem) { //if left exists and is <= to right, just push the left\n                    merged.push(leftArrayItem);\n                    leftIndex++;\n                }\n                else {\n                    merged.push(rightArrayItem); //otherwise, left is > to right so just push the right item\n                    rightIndex++;\n                }\n            }\n        }\n        else {\n            if (rightArrayItem !== undefined) {\n                merged.push(rightArrayItem);\n                rightIndex++;\n            }\n        }\n    }\n    return merged;\n}\n"]},"metadata":{},"sourceType":"module"}