{"ast":null,"code":"/*merge sort*/\nexport function doMergeSort(array) {\n  const animations = [];\n  if (array.length <= 1) return array;\n  const auxiliaryArray = array.slice();\n  divide(array, animations, auxiliaryArray);\n  return animations;\n}\n\nfunction divide(array, animations, auxiliaryArray) {\n  const midPoint = Math.ceil(array.length / 2); //rounds to next integer\n\n  const leftArray = array.slice(0, midPoint); //from start to middle item (mid item not included)\n\n  const rightArray = array.slice(midPoint); //starts at mid item (includes mid item)\n\n  if (midPoint > 1) {\n    divide(leftArray, animations, auxiliaryArray);\n    divide(rightArray, animations, auxiliaryArray);\n  }\n\n  return merge(leftArray, rightArray, animations, auxiliaryArray);\n}\n\nfunction merge(leftArray, rightArray, animations, auxiliaryArray) {\n  const leftIndex = 0; // to keep track if we visited all item of the array\n\n  const rightIndex = 0; // same here\n\n  const merged = [];\n\n  while (leftIndex < leftArray.length || rightIndex < rightArray.length) {\n    // ||=OR\n    animations.push([leftIndex, rightIndex]);\n    animations.push([leftIndex, rightIndex]);\n    const leftArrayItem = leftArray[leftIndex];\n    const rightArrayItem = rightArray[rightIndex];\n\n    if (leftArrayItem !== undefined) {\n      //if there is an item an the left\n      if (rightArrayItem === undefined) {\n        //but nothing on the right\n        merged.push(leftArrayItem); //then just push the left item to the ordered list\n\n        leftIndex++;\n      } else {\n        if (leftArrayItem <= rightArrayItem) {\n          //if left exists and is <= to right, just push the left\n          merged.push(leftArrayItem);\n          leftIndex++;\n        } else {\n          merged.push(rightArrayItem); //otherwise, left is > to right so just push the right item\n\n          rightIndex++;\n        }\n      }\n    } else {\n      if (rightArrayItem !== undefined) {\n        merged.push(rightArrayItem);\n        rightIndex++;\n      }\n    }\n  }\n\n  return merged;\n}\n\ndoMergeSort([4, 1, 6, 3, 2, 1]);","map":{"version":3,"sources":["/Users/urdoom/sorting_visualizer_react/src/sortingAlgorithms/SortingAlgorithms.js"],"names":["doMergeSort","array","animations","length","auxiliaryArray","slice","divide","midPoint","Math","ceil","leftArray","rightArray","merge","leftIndex","rightIndex","merged","push","leftArrayItem","rightArrayItem","undefined"],"mappings":"AACA;AACA,OAAO,SAASA,WAAT,CAAqBC,KAArB,EAA4B;AAC/B,QAAMC,UAAU,GAAG,EAAnB;AACA,MAAID,KAAK,CAACE,MAAN,IAAgB,CAApB,EAAuB,OAAOF,KAAP;AACvB,QAAMG,cAAc,GAAGH,KAAK,CAACI,KAAN,EAAvB;AACAC,EAAAA,MAAM,CAACL,KAAD,EAAQC,UAAR,EAAoBE,cAApB,CAAN;AACA,SAAOF,UAAP;AACH;;AAED,SAASI,MAAT,CAAgBL,KAAhB,EAAuBC,UAAvB,EAAmCE,cAAnC,EAAmD;AAC/C,QAAMG,QAAQ,GAAGC,IAAI,CAACC,IAAL,CAAUR,KAAK,CAACE,MAAN,GAAe,CAAzB,CAAjB,CAD+C,CACD;;AAC9C,QAAMO,SAAS,GAAGT,KAAK,CAACI,KAAN,CAAY,CAAZ,EAAeE,QAAf,CAAlB,CAF+C,CAEH;;AAC5C,QAAMI,UAAU,GAAGV,KAAK,CAACI,KAAN,CAAYE,QAAZ,CAAnB,CAH+C,CAGL;;AAC1C,MAAIA,QAAQ,GAAG,CAAf,EAAkB;AACdD,IAAAA,MAAM,CAACI,SAAD,EAAYR,UAAZ,EAAwBE,cAAxB,CAAN;AACAE,IAAAA,MAAM,CAACK,UAAD,EAAaT,UAAb,EAAyBE,cAAzB,CAAN;AACH;;AACD,SAAOQ,KAAK,CAACF,SAAD,EAAYC,UAAZ,EAAwBT,UAAxB,EAAoCE,cAApC,CAAZ;AACH;;AACD,SAASQ,KAAT,CAAeF,SAAf,EAA0BC,UAA1B,EAAsCT,UAAtC,EAAkDE,cAAlD,EAAkE;AAC9D,QAAMS,SAAS,GAAG,CAAlB,CAD8D,CACzC;;AACrB,QAAMC,UAAU,GAAG,CAAnB,CAF8D,CAExC;;AACtB,QAAMC,MAAM,GAAG,EAAf;;AACA,SAAOF,SAAS,GAAGH,SAAS,CAACP,MAAtB,IAAgCW,UAAU,GAAGH,UAAU,CAACR,MAA/D,EAAuE;AAAE;AACrED,IAAAA,UAAU,CAACc,IAAX,CAAgB,CAACH,SAAD,EAAYC,UAAZ,CAAhB;AACAZ,IAAAA,UAAU,CAACc,IAAX,CAAgB,CAACH,SAAD,EAAYC,UAAZ,CAAhB;AACA,UAAMG,aAAa,GAAGP,SAAS,CAACG,SAAD,CAA/B;AACA,UAAMK,cAAc,GAAGP,UAAU,CAACG,UAAD,CAAjC;;AACA,QAAIG,aAAa,KAAKE,SAAtB,EAAiC;AAAE;AAC/B,UAAID,cAAc,KAAKC,SAAvB,EAAkC;AAAE;AAChCJ,QAAAA,MAAM,CAACC,IAAP,CAAYC,aAAZ,EAD8B,CACF;;AAC5BJ,QAAAA,SAAS;AACZ,OAHD,MAIK;AACD,YAAII,aAAa,IAAIC,cAArB,EAAqC;AAAE;AACnCH,UAAAA,MAAM,CAACC,IAAP,CAAYC,aAAZ;AACAJ,UAAAA,SAAS;AACZ,SAHD,MAIK;AACDE,UAAAA,MAAM,CAACC,IAAP,CAAYE,cAAZ,EADC,CAC4B;;AAC7BJ,UAAAA,UAAU;AACb;AACJ;AACJ,KAfD,MAgBK;AACD,UAAII,cAAc,KAAKC,SAAvB,EAAkC;AAC9BJ,QAAAA,MAAM,CAACC,IAAP,CAAYE,cAAZ;AACAJ,QAAAA,UAAU;AACb;AACJ;AACJ;;AACD,SAAOC,MAAP;AACH;;AAEDf,WAAW,CAAC,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,EAAS,CAAT,EAAW,CAAX,CAAD,CAAX","sourcesContent":["\n/*merge sort*/\nexport function doMergeSort(array) {\n    const animations = [];\n    if (array.length <= 1) return array;\n    const auxiliaryArray = array.slice();\n    divide(array, animations, auxiliaryArray);\n    return animations;\n}\n\nfunction divide(array, animations, auxiliaryArray) {\n    const midPoint = Math.ceil(array.length / 2); //rounds to next integer\n    const leftArray = array.slice(0, midPoint); //from start to middle item (mid item not included)\n    const rightArray = array.slice(midPoint); //starts at mid item (includes mid item)\n    if (midPoint > 1) {\n        divide(leftArray, animations, auxiliaryArray);\n        divide(rightArray, animations, auxiliaryArray);\n    }\n    return merge(leftArray, rightArray, animations, auxiliaryArray);\n}\nfunction merge(leftArray, rightArray, animations, auxiliaryArray) {\n    const leftIndex = 0; // to keep track if we visited all item of the array\n    const rightIndex = 0; // same here\n    const merged = [];\n    while (leftIndex < leftArray.length || rightIndex < rightArray.length) { // ||=OR\n        animations.push([leftIndex, rightIndex]);\n        animations.push([leftIndex, rightIndex]);\n        const leftArrayItem = leftArray[leftIndex];\n        const rightArrayItem = rightArray[rightIndex];\n        if (leftArrayItem !== undefined) { //if there is an item an the left\n            if (rightArrayItem === undefined) { //but nothing on the right\n                merged.push(leftArrayItem); //then just push the left item to the ordered list\n                leftIndex++;\n            }\n            else {\n                if (leftArrayItem <= rightArrayItem) { //if left exists and is <= to right, just push the left\n                    merged.push(leftArrayItem);\n                    leftIndex++;\n                }\n                else {\n                    merged.push(rightArrayItem); //otherwise, left is > to right so just push the right item\n                    rightIndex++;\n                }\n            }\n        }\n        else {\n            if (rightArrayItem !== undefined) {\n                merged.push(rightArrayItem);\n                rightIndex++;\n            }\n        }\n    }\n    return merged;\n}\n\ndoMergeSort([4,1,6,3,2,1])"]},"metadata":{},"sourceType":"module"}